{"title":"Erstellen eines Exporters","content":"<p>Dieses Tutorial soll einen Überblick darüber geben, wie einfach neue Plugins für <em>sharpDox</em> \nerstellt werden können. Dafür wird ein Plugin erstellt, welches eine neue Einstellung registriert \nund einen CSV Export für alle Methoden erstellt.</p> \n<p>Dazu wird zunächst ein neues Klassenbiliotheks-Projekt in Visual Studio angelegt. Benötigt \nwerden Verweise auf <code>SharpDox.Model</code> und <code>SharpDox.Sdk</code>. \nDer erste Schritt ist die Erstellung der Konfigurationsklasse. Dazu wird eine neue Klasse \n<code>CSVConfig.cs</code> mit folgendem Inhalt angelegt:</p> \n<pre><code class=\"language-csharp line-numbers\">using System; \nusing System.ComponentModel; \nusing SharpDox.Sdk.Config; \nusing SharpDox.Sdk.Config.Attributes; \n \n// Diese Klasse implementiert das IConfigSection Interface. \n// Mit dem Name-Attribute der Klasse wird der Gruppenname innerhalb der GUI gesetzt. \n// Dieser muss angegeben werden, da die Konfiguration ansonsten nicht angezeigt wird! \n// Der zweite Parameter des Attributs gibt den Namen der String-Property innerhalb des Typen \n// CSVStrings an. \n[Name(typeof(CSVStrings), &quot;CSV&quot;)] \nnamespace CSVExporter \n{ \n    // Die Klasse implementiert das Interface IConfigSection \n    public class CSVConfig : IConfigSection \n    { \n        // An diesem Event registriert sich der ConfigController und sollte \n        // bei der Änderungen einer Einstellung aufgerufen werden. Damit \n        // wird der ConfigController über die Änderung informiert. \n        public event PropertyChangedEventHandler PropertyChanged; \n        protected void OnPropertyChanged(string propertyName) \n        { \n            PropertyChangedEventHandler handler = PropertyChanged; \n            if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName)); \n        } \n \n        // Die ist die eigentliche Einstellung. \n        private string _divider = string.Empty; \n         \n        // Ein paar Attribute für das Propertygrid der GUI \n        [Required] \n        [Name(typeof(CSVStrings), &quot;Divider&quot;)] \n        public string Divider { get { return _divider; } set { _divider = value; OnPropertyChanged(&quot;Divider&quot;); } } \n \n        // Hier muss eine GUID eingefügt werden. \n        // GUIDs können z.B. auf www.guidgen.com generiert werden. \n        // Diese wird genutzt, um die Einstellungen in der  \n        // gespeicherten .sharpDox Konfiguration zu identifizieren. \n        public Guid Guid { get { return new Guid(&quot;463e2a9d-5d26-42ac-8a02-012928988c79&quot;); } } \n    } \n}</code></pre> \n<p>In diesem Beispiel wird lediglich eine Einstellung zur Angabe des Trennzeichens hinzugefügt. \nDurch die Angaben der Attribute wird die Konfiguration automatisch im Propertygrid der GUI angezeigt und \nin der Konfigurationsdatei von <em>sharpDox</em> integriert.</p> \n<p>Als nächstes wird die <code>CSVStrings</code> Klasse erstellt.</p> \n<pre><code class=\"language-csharp line-numbers\">using SharpDox.Sdk.Local; \n \nnamespace CSVExporter \n{ \n    public class CSVStrings : ILocalStrings \n    { \n        // Strings mit der Standardübersetzung \n        private string _csv = &quot;CSV&quot;; \n        private string _divider = &quot;Divider&quot;; \n \n        // Erstellen einer Eigenschaft. \n        // Keine Auto-Properties, da sonst die Übersetzung nicht funktioniert. \n \n        public string CSV \n        { \n            get { return _csv; } \n            set { _csv = value; } \n        } \n \n        public string Divider \n        { \n            get { return _divider; } \n            set { _divider = value; } \n        } \n \n        // Setzen des Namens der Sprachdatei \n        public string DisplayName { get { return &quot;CSV&quot;; } } \n    } \n}</code></pre> \n<p>Der letzte Schritt zur Erstellung des CSV Exporters ist der Exportvorgang selbst. Dazu wird eine \nDatei <code>CSVExport.cs</code> mit folgendem Inhalt erstellt:</p> \n<pre><code class=\"language-csharp line-numbers\">using SharpDox.Model; \nusing SharpDox.Model.Repository; \nusing SharpDox.Sdk.Exporter; \nusing System; \nusing System.IO; \nusing System.Linq; \n \nnamespace CSVExporter \n{ \n    public class CSVExport : IExporter \n    { \n        /// &lt;summary&gt; \n        /// An diesem Event lauscht sharpDox, um über Warnungen während \n        /// der Überprüfung der Vorraussetzungen benachrichtigt zu werden. \n        /// Sollte eine Warnung auftreten, wird der Bauvorgang abgebrochen. \n        public event Action&lt;string&gt; OnRequirementsWarning; \n         \n        /// &lt;summary&gt; \n        /// An diesem Event lauscht sharpDox, um über Statusnachrichten \n        /// beachrichtigt zu werden. Die Nachrichten werden im  \n        /// Fortschrittsbalken angezeigt. \n        /// &lt;/summary&gt; \n        public event Action&lt;string&gt; OnStepMessage; \n         \n        /// &lt;summary&gt; \n        /// An diesem Event lauscht sharpDox, um über Statusaktualisierungen \n        /// beachrichtigt zu werden. Diese lassen den sekundären Fortschrittsbalken \n        /// fortschreiten. \n        /// &lt;/summary&gt; \n        public event Action&lt;int&gt; OnStepProgress; \n \n        private readonly CSVConfig _csvConfig; \n \n        public CSVExport(CSVConfig csvConfig) \n        { \n            // Holen unserer Konfiguration \n            _csvConfig = csvConfig; \n        } \n \n        // Die Export Funktion bekommt das eingelesene Projekt und  \n        // einen Ausgabepfad übergeben. Nun kann mit den Entitäten im Repository \n        // verfahren werden wie es gewünscht ist. In diesem Fall wird für jeden  \n        // nicht projektfremden Typen ein Eintrag in einer CSV Datei erstellt. \n        // Diese wird dann im Ausgabepfad gespeichert. \n        public void Export(SDProject sdProject, string outputPath) \n        { \n            var csv = string.Empty; \n            var types = sdProject.Repositories.Values.Single().GetAllTypes().OfType&lt;SDType&gt;().Where(o =&gt; !o.IsProjectStranger); \n             \n            foreach (var type in types) \n            { \n                ExecuteOnStepMessage(&quot;Erstelle Eintrag für &quot; + type.Fullname); \n                csv += string.Format(&quot;{1}{0}{2}{0}{3}&quot;, _csvConfig.Divider, type.Fullname, type.Name, type.Namespace) + System.Environment.NewLine; \n            } \n \n            File.WriteAllText(Path.Combine(outputPath, &quot;methods.csv&quot;), csv); \n        } \n \n        private void ExecuteOnStepMessage(string message) \n        { \n            var handler = OnStepMessage; \n            if (handler != null) \n            { \n                handler(message); \n            } \n        } \n \n        private void ExecuteOnStepProgress(int progress) \n        { \n            var handler = OnStepProgress; \n            if (handler != null) \n            { \n                handler(progress); \n            } \n        } \n \n        // Der Name wird des Exporter wird als Unterordner im Ausgabepfad erzeugt. \n        // Der komplette Ausgabepfad wird der Export-Funktion übergeben. \n        public string ExporterName { get { return &quot;csv&quot;; } } \n    } \n}</code></pre> \n<p>Damit wäre ein komplettes, rudimentäres Plugin für <em>sharpDox</em> fertiggestellt. Die resultierende \nDLL-Datei wird anschließend einfach in den <em>plugin</em> Ordner von <em>sharpDox</em> kopiert. \nDamit wird das Plugin beim Start registriert. Das Beispiel auf dieser Seite kann \n<a href=\"https://github.com/Geaz/SharpDox.Examples.Plugins.CVS\" title=\"CSV-Exporter\">hier</a> heruntergeladen werden.</p>"}